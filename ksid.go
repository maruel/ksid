// Copyright 2026 Marc-Antoine Ruel. All rights reserved.
// Use of this source code is governed under the Apache License, Version 2.0
// that can be found in the LICENSE file.

// Package ksid provides k-sortable, 64-bit unique identifiers.
//
// IDs are generated with [NewID], encoded to compact base32 Extended Hex
// strings (≤13 chars, lexicographically sortable), and decoded with [Parse].
// They implement [json.Marshaler], [json.Unmarshaler], [encoding.TextMarshaler],
// and [encoding.TextUnmarshaler] so they work transparently as JSON values and
// map keys.
//
// For multi-process deployments, call [InitIDSlice] once at startup to
// partition the slice field and guarantee no collisions across instances.
//
// [IDList] is a convenience type that marshals to/from comma-separated ID
// strings, useful for query parameters.
package ksid

import (
	"encoding/json"
	"fmt"
	"strings"
	"sync"
	"time"
)

const (
	// epoch is 2026-01-01 00:00:00 UTC in 10µs intervals.
	epoch int64 = 176722560000000

	// idEncodedLen is the fixed length of encoded IDs.
	// 64 bits / 5 bits per char = 12.8, rounded up to 13.
	idEncodedLen = 13

	// sliceMask is the bitmask for extracting the 15-bit slice value.
	sliceMask = 0x7FFF

	// alphabet is the Base32 Extended Hex alphabet.
	alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUV"
)

// decTable is a lookup table for Base32 Extended Hex decoding.
var decTable [256]byte

func init() {
	for i := range decTable {
		decTable[i] = 0xFF
	}
	for i := 0; i < len(alphabet); i++ {
		decTable[alphabet[i]] = byte(i)
		// Support lowercase for case-insensitive decoding
		if alphabet[i] >= 'A' && alphabet[i] <= 'V' {
			decTable[alphabet[i]-'A'+'a'] = byte(i)
		}
	}
}

// ID is a time-sortable 64-bit identifier resistant to collisions.
//
// IDs encode a 10µs timestamp and a monotonically increasing slice for collision
// avoidance. They are lexicographically sortable when encoded as strings, making
// them suitable for use as table keys and filenames.
//
// The zero value (0) represents an invalid/unset ID.
//
// ID structure (64 bits):
//   - Bit 63: sign (always 0, keeps int64 positive)
//   - Bits 62-15: 10µs intervals since epoch (48 bits)
//   - Bits 14-0: slice (15 bits = 32768 values per 10µs)
//
// The slice field can be partitioned across multiple processes using InitIDSlice.
// The lowest-order bits of the slice are reserved for the instance ID, ensuring
// IDs generated by different processes never collide.
//
// Time span: ~89 years from epoch (until ~2115), doublable by leveraging the 63rd bit.
//
// Max throughput: ~3.27B IDs/sec total (32768 per 10µs × 100,000 intervals/sec).
type ID uint64

var (
	idMu        sync.Mutex
	idLastT10us int64
	idSlice     int

	// idInstance is the instance ID (0 to totalInstances-1).
	idInstance int
	// idTotalInstances is the total number of parallel instances.
	// Defaults to 1 (single instance mode).
	idTotalInstances int = 1
)

// InitIDSlice configures ID generation for multi-instance deployments.
//
// When running multiple parallel processes that generate IDs, each process must
// call InitIDSlice with a unique instance number to prevent ID collisions.
// The slice field's low-order bits are partitioned among instances.
//
// Parameters:
//   - instance: this process's instance number (0 to totalInstances-1)
//   - totalInstances: total number of parallel processes
//
// Example: with 3 servers, call InitIDSlice(0, 3), InitIDSlice(1, 3), and
// InitIDSlice(2, 3) on each respective server. Each server will have a fraction
// of the maximum throughput.
//
// Must be called before any NewID calls. Returns an error if parameters are
// invalid or if totalInstances exceeds the available slice bits.
func InitIDSlice(instance, totalInstances int) error {
	if totalInstances < 1 {
		return fmt.Errorf("totalInstances must be >= 1, got %d", totalInstances)
	}
	if instance < 0 || instance >= totalInstances {
		return fmt.Errorf("instance must be in [0, %d), got %d", totalInstances, instance)
	}
	if totalInstances > sliceMask+1 {
		return fmt.Errorf("totalInstances %d exceeds max %d (slice bits)", totalInstances, sliceMask+1)
	}
	idMu.Lock()
	defer idMu.Unlock()
	idInstance = instance
	idTotalInstances = totalInstances
	return nil
}

// NewID generates a new time-based ID.
//
// IDs are guaranteed to be unique and monotonically increasing within a process.
// Multiple calls in the same 10µs interval use an incrementing slice counter.
// When multiple instances are configured via InitIDSlice, the slice counter is
// partitioned so each instance uses non-overlapping values.
// If the slice overflows, it spins until the next interval to maintain uniqueness.
func NewID() ID {
	idMu.Lock()
	for {
		t10us := max(0, time.Now().UnixMicro()/10-epoch)

		if t10us != idLastT10us {
			// New interval: reset slice to instance ID
			idLastT10us = t10us
			idSlice = idInstance
			id := newIDFromParts(uint64(t10us), uint64(idSlice)) //nolint:gosec // t10us is guaranteed non-negative by max(0, ...)
			idMu.Unlock()
			return id
		}

		// Same 10µs interval: increment slice by totalInstances
		nextSlice := idSlice + idTotalInstances
		if nextSlice <= sliceMask {
			idSlice = nextSlice
			id := newIDFromParts(uint64(t10us), uint64(idSlice)) //nolint:gosec // t10us is guaranteed non-negative by max(0, ...)
			idMu.Unlock()
			return id
		}

		// Overflow: release lock, wait, and retry
		idMu.Unlock()
		time.Sleep(time.Microsecond)
		idMu.Lock()
	}
}

func newIDFromParts(t10us, slice uint64) ID {
	// t10us: 48 bits, shifted to bits 62-15
	// slice: 15 bits, in bits 14-0
	return ID((t10us << 15) | (slice & sliceMask))
}

// String encodes the ID as a compact, sortable string.
//
// Uses base32 "Extended Hex" alphabet (0-9A-V) which is ASCII-sorted,
// ensuring lexicographic string comparison matches numeric comparison.
// Leading zero-characters are stripped for compactness. Zero IDs return "0".
func (id ID) String() string {
	if id != 0 {
		var res [13]byte
		res[0] = alphabet[(id>>59)&0x1F]
		res[1] = alphabet[(id>>54)&0x1F]
		res[2] = alphabet[(id>>49)&0x1F]
		res[3] = alphabet[(id>>44)&0x1F]
		res[4] = alphabet[(id>>39)&0x1F]
		res[5] = alphabet[(id>>34)&0x1F]
		res[6] = alphabet[(id>>29)&0x1F]
		res[7] = alphabet[(id>>24)&0x1F]
		res[8] = alphabet[(id>>19)&0x1F]
		res[9] = alphabet[(id>>14)&0x1F]
		res[10] = alphabet[(id>>9)&0x1F]
		res[11] = alphabet[(id>>4)&0x1F]
		res[12] = alphabet[(id<<1)&0x1F]
		for i := range 13 {
			if res[i] != '0' {
				return string(res[i:])
			}
		}
	}
	return "0"
}

// MarshalJSON implements json.Marshaler.
func (id ID) MarshalJSON() ([]byte, error) {
	return json.Marshal(id.String())
}

// UnmarshalJSON implements json.Unmarshaler.
func (id *ID) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	parsed, err := Parse(s)
	if err != nil {
		return err
	}
	*id = parsed
	return nil
}

// MarshalText implements encoding.TextMarshaler.
// This allows ID to be used as a map key in JSON encoding.
func (id ID) MarshalText() ([]byte, error) {
	return []byte(id.String()), nil
}

// UnmarshalText implements encoding.TextUnmarshaler.
// This allows ID to be used as a map key in JSON decoding.
func (id *ID) UnmarshalText(text []byte) error {
	parsed, err := Parse(string(text))
	if err != nil {
		return err
	}
	*id = parsed
	return nil
}

// IsZero returns true if the ID is the zero value.
func (id ID) IsZero() bool {
	return id == 0
}

// Parse parses an encoded string back to an ID.
//
// Empty string or "0" decode to zero ID. Returns an error for invalid input.
// Decoding is case-insensitive.
func Parse(s string) (ID, error) {
	if s == "0" || s == "" {
		return 0, nil
	}
	if len(s) > idEncodedLen {
		return 0, fmt.Errorf("invalid ID length: got %d, max %d", len(s), idEncodedLen)
	}

	var val [13]byte
	pad := 13 - len(s)
	for i := 0; i < pad; i++ {
		val[i] = 0
	}
	for i := 0; i < len(s); i++ {
		c := s[i]
		v := decTable[c]
		if v == 0xFF {
			return 0, fmt.Errorf("invalid ID encoding: %c", c)
		}
		val[pad+i] = v
	}

	return ID(uint64(val[0])<<59 |
		uint64(val[1])<<54 |
		uint64(val[2])<<49 |
		uint64(val[3])<<44 |
		uint64(val[4])<<39 |
		uint64(val[5])<<34 |
		uint64(val[6])<<29 |
		uint64(val[7])<<24 |
		uint64(val[8])<<19 |
		uint64(val[9])<<14 |
		uint64(val[10])<<9 |
		uint64(val[11])<<4 |
		uint64(val[12])>>1), nil
}

// Time extracts the timestamp from an ID.
//
// This is the moment this ID was generated, in UTC, at 10µs resolution.
func (id ID) Time() time.Time {
	t10us := int64(id>>15) + epoch //nolint:gosec // bit 63 is always 0, so id>>15 fits in int64
	return time.UnixMicro(t10us * 10)
}

// Slice extracts the slice counter from an ID.
//
// This is a 15-bit value.
func (id ID) Slice() int {
	return int(id & sliceMask) //nolint:gosec // sliceMask is 0x7FFF (15 bits), always fits in int
}

// Compare returns -1 if id < other, 0 if equal, 1 if id > other.
func (id ID) Compare(other ID) int {
	if id < other {
		return -1
	}
	if id > other {
		return 1
	}
	return 0
}

// IDList is a slice of IDs that can unmarshal from a comma-separated string.
// Useful for query parameters like ?ids=ABC,DEF,GHI.
type IDList []ID

// UnmarshalText implements encoding.TextUnmarshaler for query param parsing.
func (l *IDList) UnmarshalText(text []byte) error {
	s := string(text)
	if s == "" {
		*l = nil
		return nil
	}

	parts := strings.Split(s, ",")
	ids := make([]ID, 0, len(parts))
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}
		id, err := Parse(part)
		if err != nil {
			return fmt.Errorf("invalid ID %q: %w", part, err)
		}
		if !id.IsZero() {
			ids = append(ids, id)
		}
	}
	*l = ids
	return nil
}

// MarshalText implements encoding.TextMarshaler.
func (l IDList) MarshalText() ([]byte, error) {
	if len(l) == 0 {
		return nil, nil
	}
	strs := make([]string, len(l))
	for i, id := range l {
		strs[i] = id.String()
	}
	return []byte(strings.Join(strs, ",")), nil
}
